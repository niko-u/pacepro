# PacePro Bug Hunt Report — 2026-01-31

Auditor: Claude (automated code review)  
Scope: Backend (`pacepro`) + Mobile (`pacepro-mobile`) — all recently changed files  
Date: January 31, 2026

---

## Summary

| Severity | Count |
|----------|-------|
| CRITICAL | 3     |
| MAJOR    | 9     |
| MINOR    | 8     |
| **Total**| **20**|

---

## CRITICAL

### BUG-001: Strava `token_expires_at` type mismatch — token refresh will NEVER trigger
**File:** `src/app/api/webhooks/strava/route.ts`, line 76–82  
**Severity:** CRITICAL

The `getValidStravaToken()` function types `token_expires_at` as `number` (Unix epoch seconds) and compares it numerically:
```ts
integration: { ...; token_expires_at: number }
// ...
if (integration.token_expires_at && integration.token_expires_at > now + 60) {
```

However, the database schema (`supabase/schema.sql` line 125) defines `token_expires_at` as `TIMESTAMPTZ`, and the Strava callback (`callback/route.ts` line 103) stores it as an ISO string:
```ts
token_expires_at: new Date(expires_at * 1000).toISOString()
```

When Supabase returns a `TIMESTAMPTZ`, the JS client delivers it as an ISO string like `"2026-02-01T12:00:00.000Z"`. Comparing a string against a number with `>` will coerce the string to `NaN`, so `NaN > 1738339200` is always `false`. **The token will be considered expired on every single webhook call**, causing unnecessary token refreshes on every Strava activity.

Worse: if the `refresh_token` ever becomes invalid (user deauthorizes), every single webhook will fail because it never uses the cached access token.

**Fix:** Parse `token_expires_at` into a Unix timestamp before comparing:
```ts
const expiresAt = typeof integration.token_expires_at === 'number'
  ? integration.token_expires_at
  : Math.floor(new Date(integration.token_expires_at).getTime() / 1000);

if (expiresAt && expiresAt > now + 60) {
  return integration.access_token;
}
```

Also update the type annotation to `token_expires_at: string | number`.

Note: `src/lib/integrations/whoop.ts` (line 66) handles this correctly by using `new Date(integration.token_expires_at).getTime()`.

---

### BUG-002: Strava token refresh saves `expires_at` as raw epoch — format inconsistency causes cascading failures
**File:** `src/app/api/webhooks/strava/route.ts`, line 111  
**Severity:** CRITICAL

After a token refresh, the webhook route stores the raw Strava `expires_at` (Unix epoch in seconds):
```ts
await supabase.from("integrations").update({
  access_token: data.access_token,
  refresh_token: data.refresh_token,
  token_expires_at: data.expires_at,  // Raw number, e.g. 1738339200
});
```

But the column is `TIMESTAMPTZ`. Writing a bare integer to a `TIMESTAMPTZ` column will be interpreted as a PostgreSQL epoch-based timestamp — but it's ambiguous and implementation-dependent. The callback route writes ISO strings. This creates inconsistency: some rows have ISO strings, some have epoch integers.

**Fix:** Convert to ISO string consistently:
```ts
token_expires_at: new Date(data.expires_at * 1000).toISOString(),
```

Compare with `src/lib/integrations/strava.ts` line 83 which does this correctly:
```ts
token_expires_at: new Date(refreshed.expires_at * 1000).toISOString(),
```

---

### BUG-003: Duplicate coach messages in mobile chat from real-time subscription
**File (mobile):** `app/(tabs)/chat.tsx`, lines 149–169 (real-time) vs 194–206 (handleSend)  
**Severity:** CRITICAL (UX — user sees every AI reply twice)

When the user sends a message, `handleSend()` calls `sendChatMessage()` which returns the reply text. The handler then creates a local message with id `coach-${Date.now()}` and appends it. Simultaneously, the real-time subscription fires for the INSERT on `chat_messages` and creates a message with the actual DB UUID as its id.

The dedup check:
```ts
if (prev.some((m) => m.id === mapped.id)) return prev;
```
compares `coach-1738300000000` against the UUID `a1b2c3d4-...` — they'll **never match**, so the message is added a second time.

**Fix:** Either:

**(A)** In `handleSend`, use the DB id returned from the API for the coach message. This requires the `/api/chat` endpoint to return the message id (which it currently doesn't).

**(B)** Skip real-time additions for assistant messages that arrive within a few seconds of a `sendChatMessage` call:
```ts
const lastSendTimestamp = useRef<number>(0);

// In handleSend, before setSending(true):
lastSendTimestamp.current = Date.now();

// In real-time handler:
if (newMsg.role === 'assistant' && Date.now() - lastSendTimestamp.current < 10000) return;
```

**(C)** Best approach: Have the API return the assistant message ID, use it as the local message ID, and the dedup works naturally.

---

## MAJOR

### BUG-004: `generatePlan()` doesn't set `total_weeks`, `current_week`, or `current_phase` on the training plan
**File:** `src/lib/coach/plan-engine.ts`, lines 1459–1471  
**Severity:** MAJOR

The `training_plans` INSERT only includes `plan_config`, `starts_at`, `ends_at`, etc. It never sets:
- `total_weeks` (the migration adds this column; context.ts reads it at line 76)
- `current_week` (defaults to 1 per migration, but should be 0)
- `current_phase` (defaults to NULL)

The `CoachContext` at `context.ts` line 217 renders:
```ts
parts.push(`\nPLAN: Week ${plan.current_week}/${plan.total_weeks}, Phase: ${plan.current_phase || "training"}`);
```
With `total_weeks = NULL`, this renders as `Week 1/null` — confusing the AI coach and potentially causing bad advice.

**Fix:** Add these fields to the INSERT:
```ts
total_weeks: totalWeeks,
current_week: 0,
current_phase: phases[0]?.name || 'base',
```

---

### BUG-005: Webhook error logging uses PostgREST JSON path operator incorrectly
**File:** `src/app/api/webhooks/strava/route.ts`, line 302  
**Severity:** MAJOR

```ts
.eq("payload->object_id", activityId);
```

PostgREST uses `->` for JSON traversal in column names, but the Supabase JS client doesn't support this operator syntax in `.eq()`. The correct PostgREST syntax is `payload->object_id` as a column reference, but the value comparison requires `::text` casting or using `.filter()`. In practice, **this query will silently fail to match any rows**, so webhook errors are never recorded.

**Fix:** Use the event_id which was already stored:
```ts
.eq("event_id", eventId);
```
This is simpler, correct, and already matches the insert at line 48.

---

### BUG-006: Race condition — webhook event INSERT then idempotency check can cause duplicate processing
**File:** `src/app/api/webhooks/strava/route.ts`, lines 44–57 and 117–147  
**Severity:** MAJOR

The POST handler first INSERTs into `webhook_events` (line 48), then calls `processStravaActivity()`. Inside that function, it checks `webhook_events` for `processed = true` (line 137). But since the event was **just inserted** with `processed = false` (default), this check will always pass.

If Strava sends the same event twice before the first one finishes processing, both will pass the idempotency check because neither has been marked `processed = true` yet. The `workouts` table check (line 122) mitigates this for the final insert, but the expensive AI analysis and Strava API calls will still run twice.

Additionally, the `webhook_events` table has `UNIQUE(provider, event_id)`, so the second INSERT at line 48 will **throw an error** (duplicate key), causing the entire handler to return a 200 in the catch block — but silently swallowing the event.

**Fix:**
1. Use `upsert` with `onConflict` for the initial event INSERT, or use `INSERT ... ON CONFLICT DO NOTHING` and check if the row was actually inserted.
2. Move the idempotency check before the INSERT, or use `INSERT ... ON CONFLICT DO NOTHING RETURNING id` and skip processing if no row was returned.

```ts
const { data: inserted, error: insertError } = await supabase
  .from("webhook_events")
  .upsert(
    { provider: "strava", event_type: event.aspect_type, event_id: eventId, payload: event },
    { onConflict: "provider,event_id", ignoreDuplicates: true }
  )
  .select("id, processed")
  .single();

if (!inserted || inserted.processed) {
  console.log(`Event ${eventId} already handled, skipping`);
  return NextResponse.json({ received: true });
}
```

---

### BUG-007: `adaptAfterWorkout` uses `isHardSession` on `WorkoutRow` data from Supabase, but `intensity` field isn't included in the select
**File:** `src/lib/coach/adaptation.ts`, lines 157–168 (isHardSession) and various callers  
**Severity:** MAJOR

The `isKeySession()` and `isHardSession()` functions check `workout.title` but never check the `intensity` column. The `adaptAfterWorkout` function receives `completedWorkout` from the Strava webhook (line 268 of strava/route.ts) which uses `select("*")`, so this works.

However, `findRescheduleSlot()` (line 671) does `select("id")` and then passes the result to `isHardSession()`, which tries to read `title`, `workout_type`, and `duration_minutes` — all undefined because only `id` was selected.

```ts
const { data: existing } = await supabase
  .from("workouts")
  .select("id")  // BUG: isHardSession needs title, workout_type, duration_minutes
  .eq("user_id", userId)
  .eq("scheduled_date", candidate)
  .eq("status", "scheduled");

const hasHard = ((existing || []) as WorkoutRow[]).some(isHardSession);
```

`isHardSession` will always return `false` (all checks fail on undefined values), so the first candidate date is always returned. Missed key sessions may be rescheduled on top of existing hard sessions.

**Fix:** Change the select to include the needed fields:
```ts
.select("id, title, workout_type, duration_minutes")
```

---

### BUG-008: In-memory rate limiter provides no protection on Vercel serverless
**File:** `src/lib/rate-limit.ts`, entire file  
**Severity:** MAJOR (acknowledged in comments, but still deployed)

The rate limiter uses a `Map()` in module scope. On Vercel, each invocation can run in a fresh isolate, so the Map is empty. A user could send 1000 requests that each hit a different isolate and never be rate limited.

The code comments acknowledge this and suggest Upstash Redis. For production, this is a real vulnerability for:
- Chat API (30 msg/min limit, line 95) — a user can burn OpenAI credits rapidly
- Plan generation (3/hour limit, line 101) — less critical

**Fix:** Implement with `@upstash/ratelimit` + `@upstash/redis` as suggested in comments, or add a DB-based rate check.

---

### BUG-009: `extendPlan` doesn't check for existing workouts on the target week — can create duplicate workouts
**File:** `src/lib/coach/plan-engine.ts`, `extendPlan()` ~line 1614  
**Severity:** MAJOR

The `extendPlan` function calculates `nextWeekStart` from the last scheduled workout date + 7 days. But if the cron job runs twice before new workouts are created (or if the last workout was in the past), it could generate workouts for a week that already has workouts.

There's no check like:
```ts
const { data: existing } = await supabase
  .from("workouts")
  .select("id")
  .eq("plan_id", plan.id)
  .gte("scheduled_date", toISODate(nextWeekStart))
  .lte("scheduled_date", toISODate(addDays(nextWeekStart, 6)));

if (existing && existing.length > 0) {
  return { workoutsCreated: 0 };
}
```

The cron job at `plan-extend/route.ts` runs for all active plans, and if a run is slow/fails partway, a retry could cause duplicates.

**Fix:** Add a duplicate check before inserting, or use a database-level unique constraint on `(plan_id, scheduled_date, workout_type)`.

---

### BUG-010: `regenerateTrainingPlan()` in mobile doesn't pass userId — backend needs it for auth
**File (mobile):** `lib/api.ts`, `regenerateTrainingPlan()` line ~198  
**Severity:** MAJOR

The mobile function sends an empty JSON body:
```ts
body: JSON.stringify({}),
```

The backend at `plans/regenerate/route.ts` checks: if it's a service call, it requires `body.userId`. If it's a user call, it uses `getApiUser(req)`.

However, `getApiUser` calls `req.json()` internally? No — actually it doesn't. It reads the auth header. But the issue is that the `POST` handler at line 34 calls `await req.json()` for the service call path, and for the user path it calls `getApiUser(req)`. Since `req.json()` is only called in the service path, there's no actual bug here from the request body perspective.

Wait — actually there IS a problem. The handler reads `req.json()` in the service call branch (line 37). In the user branch, it never reads the body. But the Next.js request body can only be read once. If the auth header doesn't match service role, but the body IS `{}`, the code falls through to `getApiUser(req)` which works fine.

**Revised severity: No bug here.** Auth via Bearer token works correctly. Removing this entry.

---

### BUG-010 (revised): `calculatePhases` can produce negative `baseWeeks`
**File:** `src/lib/coach/plan-engine.ts`, lines 263–268  
**Severity:** MAJOR

```ts
const totalWeeks = Math.max(4, weeksBetween(startDate, raceDate));
const taperWeeks = Math.max(2, Math.round(totalWeeks * 0.1));
const peakWeeks = Math.max(1, Math.round(totalWeeks * 0.2));
const buildWeeks = Math.max(1, Math.round(totalWeeks * 0.3));
const baseWeeks = totalWeeks - taperWeeks - peakWeeks - buildWeeks;
```

For `totalWeeks = 4`:
- `taperWeeks = max(2, round(0.4)) = 2`
- `peakWeeks = max(1, round(0.8)) = 1`
- `buildWeeks = max(1, round(1.2)) = 1`
- `baseWeeks = 4 - 2 - 1 - 1 = 0`

For `totalWeeks = 4` this gives 0 base weeks (acceptable). But for very short plans (4-5 weeks), if the Math.round rounds up, `baseWeeks` could go negative. With `totalWeeks = 4`:
- Actually: 4 - 2 - 1 - 1 = 0. With `totalWeeks = 5`: 5 - 2 - 1 - 2 = 0. This just barely avoids negatives.

However, the code at line 271 does `if (baseWeeks > 0)` before pushing the phase, so a zero-length base phase is silently dropped. This is acceptable but worth noting that short plans (< 6 weeks to race) will have no base phase at all.

**Revised severity:** MINOR — edge case, doesn't crash.

---

### BUG-011: Chat real-time subscription can receive messages from `sendChatMessage` response AND real-time, but dedup only works for exact DB id matches
**File (mobile):** `app/(tabs)/chat.tsx`  
**Severity:** See BUG-003 (this is the same issue, already covered as CRITICAL)

---

### BUG-012: `handleMissedWorkouts` counts "scheduled" workouts as missed when querying the current week
**File:** `src/lib/coach/adaptation.ts`, lines 494–501  
**Severity:** MAJOR

```ts
const weekScheduled = (weekWorkouts || []).filter(
  (w) => w.status === "scheduled" || w.status === "skipped"
);
const weeklyMissCount = weekScheduled.length;
```

This counts ALL workouts with status "scheduled" or "skipped" for the current week as "missed." But "scheduled" workouts for today and future days this week haven't been missed yet — they haven't happened! Only yesterday's "scheduled" workouts (the ones in the `missed` array) are actually missed.

If it's Monday, and there are 5 scheduled workouts for Tue-Sat, all 5 will be counted as "missed" plus any from yesterday, triggering the 3+ missed threshold incorrectly. This would reduce next week's volume for every user every Monday.

**Fix:** Only count workouts from dates **before today**:
```ts
const weekScheduled = (weekWorkouts || []).filter(
  (w) => (w.status === "scheduled" && w.scheduled_date < today) || w.status === "skipped"
);
```

---

## MINOR

### BUG-013: `buildCoachContext` uses `new Date()` directly instead of user's timezone
**File:** `src/lib/coach/context.ts`, line 103  
**Severity:** MINOR

```ts
const today = new Date().toISOString().split("T")[0];
```

This uses UTC to determine "today," but the user may be in a different timezone. The plan engine correctly uses `getUserToday(timezone)`, but the context builder doesn't.

At midnight UTC, a user in California (UTC-8) would see workouts from "tomorrow" as "today's workout," or miss seeing today's actual workout.

**Fix:** Accept `timezone` parameter and use `getUserToday()` from plan-engine:
```ts
const today = getUserToday(profile?.timezone);
```

---

### BUG-014: `extractPreferences` function signature mismatch between declaration and call site
**File:** `src/lib/coach/ai.ts`, line 166 vs `src/app/api/chat/route.ts`, line 68  
**Severity:** MINOR

Declaration:
```ts
export async function extractPreferences(
  userMessage: string,
  coachResponse: string,
  userId?: string  // optional third param
): Promise<Record<string, string[]>>
```

Call site in chat route:
```ts
extractPreferences(message, response)
```

This works because `userId` is optional. However, the `userId` is available and should be passed for usage tracking. Without it, `logUsage` at line 181 is called with `undefined` userId, which will insert a NULL user_id into `ai_usage` — likely violating a NOT NULL constraint or making usage data useless.

**Fix:**
```ts
extractPreferences(message, response, user.id)
```

---

### BUG-015: Mobile dashboard `getWeeklyStats` uses Sunday-Saturday week, but backend uses Monday-Sunday
**File (mobile):** `lib/api.ts`, `getWeeklyStats()`, lines ~370  
**Severity:** MINOR

```ts
startOfWeek.setDate(now.getDate() - now.getDay()); // Sunday
endOfWeek.setDate(startOfWeek.getDate() + 6); // Saturday
```

The dashboard (`app/(tabs)/index.tsx` line 82) uses Monday-Sunday. The plan engine uses Monday-Sunday. But `getWeeklyStats` uses Sunday-Saturday. This causes week boundaries to be off by one day.

**Fix:** Use Monday-Sunday consistently:
```ts
const dayOfWeek = now.getDay();
const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
startOfWeek.setDate(now.getDate() + mondayOffset);
endOfWeek.setDate(startOfWeek.getDate() + 6);
```

---

### BUG-016: `adaptation.ts` `getToday()` and `getYesterday()` use UTC, not user timezone
**File:** `src/lib/coach/adaptation.ts`, lines 112–119  
**Severity:** MINOR

```ts
function getToday(): string {
  return new Date().toISOString().split("T")[0];
}
```

Same issue as BUG-013. When comparing workout dates (which are stored relative to user's timezone), UTC-based "today" can cause off-by-one day errors for users far from UTC.

**Fix:** Pass user's timezone through the adaptation functions or use a shared `getUserToday()` utility.

---

### BUG-017: `generatePlan` and `regenerate` both cancel old plans but don't coordinate — double regeneration race condition
**File:** `src/app/api/plans/regenerate/route.ts` and `src/app/api/plans/generate/route.ts`  
**Severity:** MINOR

Both endpoints cancel active plans and generate new ones. If the mobile app calls both (e.g., TrainingProfile triggers `regenerateTrainingPlan()` while another part calls `generateTrainingPlan()`), both will cancel each other's newly created plan in a race condition. The user could end up with two active plans or zero.

**Fix:** Add a database-level unique constraint: `UNIQUE(user_id) WHERE status = 'active'` (partial unique index), or use a distributed lock.

---

### BUG-018: `chat-plan-modifier.ts` creates a new Supabase service client for every call
**File:** `src/lib/coach/chat-plan-modifier.ts`, `getServiceSupabase()` line 12  
**Severity:** MINOR (performance)

This is actually fine — it uses the same lazy-init pattern as everywhere else. Not a bug.

**Revised: Removed.**

---

### BUG-018 (revised): `calculatePhases` assigns alternating `base`/`build` names for rolling plans, which can cause wrong template selection
**File:** `src/lib/coach/plan-engine.ts`, `rolling4WeekCycles()` line 239  
**Severity:** MINOR

```ts
const phaseName = phases.length % 2 === 0 ? "base" : "build";
```

This alternates base/build/base/build for rolling (no race date) plans. However, `buildRunningTemplates` produces significantly different workouts for "build" (intervals, tempo) vs "base" (mostly easy + long). Athletes on a no-race rolling plan will flip between very different training structures every 4 weeks, which is unusual for a maintenance plan.

**Fix:** Consider using consistent "base" phase for rolling plans, or a more gradual progression approach.

---

### BUG-019: `mapStravaType` maps `Walk` and `Hike` to `run` workout type
**File:** `src/app/api/webhooks/strava/route.ts`, `mapStravaType()` line ~326  
**Severity:** MINOR

Mapping walks and hikes as "run" means the system may match a walk to a scheduled run workout and mark it completed. A 2-hour hike would be considered a completed training run, distorting training load analysis and potentially triggering over-performance adaptation.

**Fix:** Map `Walk` and `Hike` to a separate type (or `rest`/unmatched), or check distance/pace thresholds.

---

### BUG-020: WHOOP sync cron doesn't call `adaptForRecovery()` after storing new data
**File:** `src/app/api/cron/whoop-sync/route.ts`  
**Severity:** MINOR

The WHOOP sync stores recovery data but never calls `adaptForRecovery()` from `adaptation.ts`. Recovery data is stored, but the adaptation engine that modifies upcoming workouts based on recovery scores is never triggered. The user's plan won't auto-adjust to poor recovery unless they happen to complete a Strava workout (which triggers `adaptAfterWorkout`).

**Fix:** After successful upsert, call:
```ts
import { adaptForRecovery, executeAdaptationActions } from "@/lib/coach/adaptation";

// After upsert succeeds:
if (recoveryScore !== null) {
  const adaptResult = await adaptForRecovery(supabase, userId, {
    recovery_score: recoveryScore,
    hrv_ms: hrvMs ?? undefined,
    sleep_hours: sleepHours ?? undefined,
  });
  if (adaptResult.actions.length > 0 || adaptResult.message) {
    await executeAdaptationActions(supabase, userId, adaptResult);
  }
}
```

---

## Additional Notes

### Not-a-bug: OAuth CSRF implementation
The Strava OAuth CSRF flow (`connect/route.ts` + `callback/route.ts`) is correctly implemented:
- Connect generates a nonce, stores it in an httpOnly cookie, and embeds it (with userId) in the OAuth state parameter.
- Callback extracts the nonce from state, compares against the cookie, verifies the authenticated user matches, and clears the cookie.
- The only edge case is that the `state` encodes `returnTo` which could contain `:` characters, but `parts.slice(2).join(":")` handles this correctly.

### Not-a-bug: GPT-4o-mini routing
The codebase correctly routes expensive calls (chat, analysis) to `gpt-4o` and cheaper calls (workout extraction, plan modification detection, coach notes, conversation compression) to `gpt-4o-mini`. This is appropriate cost optimization.

### Performance concern: Plan extension cron iterates all active plans sequentially
The `plan-extend` cron processes plans one at a time in a for loop. With many users, this could timeout on Vercel (default 10s, max 300s for Pro). Consider parallel processing with `Promise.allSettled()` or batching.

---

## Priority Fix Order

1. **BUG-001** + **BUG-002**: Strava token type mismatch (causes unnecessary API calls on every webhook)
2. **BUG-003**: Duplicate chat messages (visible UX bug for every user, every message)
3. **BUG-006**: Webhook idempotency race condition (can cause double AI processing + errors)
4. **BUG-004**: Missing `total_weeks`/`current_phase` on plan creation (bad AI context for all users)
5. **BUG-012**: Missed workout miscounting (false positive for all users, especially early in the week)
6. **BUG-007**: `findRescheduleSlot` missing select fields (broken missed-workout rescheduling logic)
7. **BUG-005**: Webhook error logging (silent failure, debugging blind spot)
8. **BUG-009**: `extendPlan` duplicate workout risk
9. **BUG-008**: In-memory rate limiter (security concern)
10. **BUG-020**: WHOOP recovery not triggering adaptation
11. Remaining MINOR bugs
